# -*- coding: utf-8 -*-
"""Materiais.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12Qxp6EAGWt-S6qEphtKRoKpTJsmLTh9v
"""
# =========================================================
# CEMINAS - GERADOR DE RELA√á√ÉO DE MATERIAIS
# Interface Web Interativa (Streamlit Cloud)
# ---------------------------------------------------------
# Autor: Ellen Lousada / Engenharia Ceminas
# Vers√£o: 2025.11 (Fluxo com estado persistente)
# =========================================================

import streamlit as st
import pandas as pd
import os
from io import BytesIO

# ‚öôÔ∏è Configura√ß√£o de p√°gina deve ser o PRIMEIRO comando Streamlit
st.set_page_config(page_title="Ceminas - Lista de Materiais", page_icon="‚ö°", layout="centered")

# --------------------- Config p√°gina + estilo ---------------------
st.set_page_config(page_title="Ceminas - Lista de Materiais", page_icon="‚ö°", layout="centered")
st.markdown("""
    <style>
        .main { background-color: #E6F0FF; }
        .title { text-align: center; font-size: 36px; font-weight: 800; color: #003366; margin-top: 10px; }
        .subtitle { text-align: center; font-size: 18px; color: #333; margin-bottom: 30px; }
        .stButton>button {
            background-color: #003366; color: #fff; font-weight: 700;
            border-radius: 8px; padding: .6em 1.2em; transition: 0.3s;
        }
        .stButton>button:hover { background-color: #0059b3; color: #fff; }
    </style>
""", unsafe_allow_html=True)

# --------------------- Logo ---------------------
logo_path = "Logo Ceminas.jpeg"
if os.path.exists(logo_path):
    st.image(logo_path, use_column_width=False, width=250)
else:
    st.warning("‚ö†Ô∏è Logotipo n√£o encontrado (Logo Ceminas.jpeg).")
st.markdown('<div class="title">CEMINAS ‚Äì Gerador de Rela√ß√£o de Materiais</div>', unsafe_allow_html=True)
st.markdown('<div class="subtitle">Ferramenta interna para consolida√ß√£o de materiais de redes de distribui√ß√£o</div>', unsafe_allow_html=True)
st.divider()

# --------------------- Autentica√ß√£o simples ---------------------
senha_correta = "Ceminas2025"
if "auth" not in st.session_state:
    st.session_state["auth"] = False
if not st.session_state["auth"]:
    senha = st.text_input("üîê Digite a senha de acesso:", type="password")
    if senha == senha_correta:
        st.session_state["auth"] = True
        st.success("Acesso liberado! ‚úÖ")
        st.rerun()
    else:
        st.stop()

# --------------------- Estado global do fluxo ---------------------
# Flags para controlar as fases (evita depender do estado do bot√£o ap√≥s rerun)
st.session_state.setdefault("pending_generate", False)        # queremos gerar agora?
st.session_state.setdefault("corrections_submitted", False)   # corre√ß√µes foram submetidas?
st.session_state.setdefault("correcoes_dict", {})             # dicion√°rio de corre√ß√µes
st.session_state.setdefault("correcoes_choices", {})          # escolhas do selectbox
st.session_state.setdefault("obra", "Nova Obra")              # nome da obra persistente

# --------------------- Upload ---------------------
st.header("üì§ Enviar planilha de estruturas do projeto")
uploaded_file = st.file_uploader("Envie o arquivo **EstruturasProjeto.xlsx**", type=["xlsx"])

banco_estruturas = "MateriaisEstrutura.xlsx"  # precisa existir no reposit√≥rio

if uploaded_file is not None:
    st.success("‚úÖ Arquivo recebido com sucesso!")
    projeto_path = "EstruturasProjeto.xlsx"
    with open(projeto_path, "wb") as f:
        f.write(uploaded_file.read())

    st.divider()
    st.header("üèóÔ∏è Configura√ß√£o da Obra")
    st.session_state["obra"] = st.text_input("Nome da obra:", st.session_state["obra"])
    obra_limpa = "".join(c for c in st.session_state["obra"] if c.isalnum() or c in (" ", "-", "_")).strip()
    arquivo_saida = f"Ceminas - Materiais - {obra_limpa}.xlsx"

    # Bot√£o para iniciar valida√ß√£o + gera√ß√£o
    iniciar = st.button("‚öôÔ∏è Validar e Gerar Rela√ß√£o")
    if iniciar:
        st.session_state["pending_generate"] = True
        st.session_state["corrections_submitted"] = False  # reinicia passo de corre√ß√£o
        st.session_state["correcoes_dict"] = {}
        st.session_state["correcoes_choices"] = {}
        st.rerun()

    # Se devemos gerar (seja por clique, seja ap√≥s envio do form), processa:
    if st.session_state["pending_generate"]:
        try:
            # ---------- Leitura e normaliza√ß√£o ----------
            estruturas = pd.read_excel(banco_estruturas, engine="openpyxl")
            projeto = pd.read_excel(projeto_path, engine="openpyxl")

            for df in [estruturas, projeto]:
                df.columns = df.columns.str.strip().str.upper()
                for col in df.select_dtypes(include=["object"]).columns:
                    df[col] = df[col].astype(str).str.strip().str.upper()

            # Evita "NAN" nas op√ß√µes:
            for col in ["ESTRUTURA", "EQUIPAMENTO", "CONDUTOR", "POSTE"]:
                estruturas[col] = estruturas[col].fillna("").astype(str)
                projeto[col]    = projeto[col].fillna("").astype(str)

            keys = ["ESTRUTURA", "EQUIPAMENTO", "CONDUTOR", "POSTE"]
            chaves_banco = estruturas[keys].drop_duplicates()
            chaves_proj  = projeto[keys].drop_duplicates()

            faltantes = (
                chaves_proj.merge(chaves_banco, on=keys, how="left", indicator=True)
                .query('_merge == "left_only"')
                .drop(columns="_merge")
                .reset_index(drop=True)
            )

            # ---------- Etapa de Corre√ß√£o (se necess√°rio e ainda n√£o submetida) ----------
            if len(faltantes) > 0 and not st.session_state["corrections_submitted"]:
                st.warning(f"‚ö†Ô∏è Foram encontradas {len(faltantes)} combina√ß√µes inexistentes no banco.")
                st.markdown("Selecione abaixo como tratar cada uma:")

                with st.form("corrigir_faltantes", clear_on_submit=False):
                    for i, row in faltantes.iterrows():
                        estrutura  = row["ESTRUTURA"]
                        equipamento = row["EQUIPAMENTO"]
                        condutor   = row["CONDUTOR"]
                        poste      = row["POSTE"]

                        st.markdown(
                            f"**‚ùå Estrutura:** {estrutura} | **Equipamento:** {equipamento} | "
                            f"**Condutor:** {condutor} | **Poste:** {poste}"
                        )

                        # Sugest√µes cadastradas na MESMA estrutura
                        sugestoes = (
                            estruturas[estruturas["ESTRUTURA"] == estrutura][["EQUIPAMENTO", "CONDUTOR", "POSTE"]]
                            .drop_duplicates()
                            .sort_values(by=["EQUIPAMENTO","CONDUTOR","POSTE"])
                            .reset_index(drop=True)
                        )

                        if sugestoes.empty:
                            st.info("üîπ Nenhuma varia√ß√£o cadastrada dessa estrutura ‚Äî ela ser√° ignorada.")
                            # Mesmo sem op√ß√µes, seguimos adiante (ignorar)
                            st.divider()
                            continue

                        opcoes = ["Ignorar esta estrutura"] + [
                            f"{r['EQUIPAMENTO']} | {r['CONDUTOR']} | {r['POSTE']}"
                            for _, r in sugestoes.iterrows()
                            if f"{r['EQUIPAMENTO']}{r['CONDUTOR']}{r['POSTE']}".strip() != ""
                        ]

                        key_sel = f"choice::{estrutura}::{equipamento}::{condutor}::{poste}::{i}"
                        escolha_default = st.session_state["correcoes_choices"].get(key_sel, opcoes[0])

                        escolha = st.selectbox(
                            f"Selecione uma alternativa para {estrutura}:",
                            options=opcoes,
                            index=opcoes.index(escolha_default) if escolha_default in opcoes else 0,
                            key=key_sel,
                        )
                        st.session_state["correcoes_choices"][key_sel] = escolha
                        st.divider()

                    submitted = st.form_submit_button("‚úÖ Aplicar Corre√ß√µes e Gerar Rela√ß√£o")

                if submitted:
                    # Monta dicion√°rio de corre√ß√µes e segue para gera√ß√£o sem precisar clicar de novo
                    correcoes = {}
                    for i, row in faltantes.iterrows():
                        estrutura  = row["ESTRUTURA"]
                        equipamento = row["EQUIPAMENTO"]
                        condutor   = row["CONDUTOR"]
                        poste      = row["POSTE"]
                        key_sel    = f"choice::{estrutura}::{equipamento}::{condutor}::{poste}::{i}"
                        escolha    = st.session_state["correcoes_choices"].get(key_sel, "Ignorar esta estrutura")
                        if escolha != "Ignorar esta estrutura":
                            eq, cond, pst = [x.strip() for x in escolha.split("|")]
                            correcoes[(estrutura, equipamento, condutor, poste)] = {
                                "EQUIPAMENTO": eq, "CONDUTOR": cond, "POSTE": pst
                            }

                    st.session_state["correcoes_dict"] = correcoes
                    st.session_state["corrections_submitted"] = True
                    st.rerun()
                else:
                    # Espera submiss√£o do form
                    st.stop()

            # ---------- Aplicar corre√ß√µes (se houver) ----------
            correcoes = st.session_state.get("correcoes_dict", {})
            projeto_corrigido = projeto.copy()
            if correcoes:
                for idx, row in projeto.iterrows():
                    chave = (row["ESTRUTURA"], row["EQUIPAMENTO"], row["CONDUTOR"], row["POSTE"])
                    if chave in correcoes:
                        novo = correcoes[chave]
                        projeto_corrigido.loc[idx, ["EQUIPAMENTO", "CONDUTOR", "POSTE"]] = [
                            novo["EQUIPAMENTO"], novo["CONDUTOR"], novo["POSTE"]
                        ]

                # (opcional) resumo visual das corre√ß√µes
                resumo = []
                for (est, eqo, cond_o, pst_o), novo in correcoes.items():
                    resumo.append({
                        "ESTRUTURA": est,
                        "EQUIPAMENTO_ORIG": eqo,
                        "CONDUTOR_ORIG": cond_o,
                        "POSTE_ORIG": pst_o,
                        "EQUIPAMENTO_NOVO": novo["EQUIPAMENTO"],
                        "CONDUTOR_NOVO": novo["CONDUTOR"],
                        "POSTE_NOVO": novo["POSTE"],
                    })
                if resumo:
                    st.info("üßæ Corre√ß√µes aplicadas:")
                    st.dataframe(pd.DataFrame(resumo), use_container_width=True)

            # ---------- Consolida√ß√£o final ----------
            materiais_lista = []
            for _, row in projeto_corrigido.iterrows():
                flt = (
                    (estruturas["ESTRUTURA"] == row["ESTRUTURA"])
                    & (estruturas["EQUIPAMENTO"] == row["EQUIPAMENTO"])
                    & (estruturas["CONDUTOR"] == row["CONDUTOR"])
                    & (estruturas["POSTE"] == row["POSTE"])
                )
                encontrados = estruturas.loc[flt].copy()
                if not encontrados.empty:
                    encontrados["QTD_PROJETO"] = row["QUANTIDADE"]
                    materiais_lista.append(encontrados)

            if materiais_lista:
                materiais = pd.concat(materiais_lista, ignore_index=True)
                materiais["QTD_TOTAL"] = materiais["QUANTIDADE"] * materiais["QTD_PROJETO"]
                relacao = (
                    materiais.groupby(["CODIGO", "DESCRI√á√ÉO", "UNIDADE"], as_index=False)["QTD_TOTAL"]
                    .sum()
                    .sort_values("DESCRI√á√ÉO")
                )

                buffer = BytesIO()
                relacao.to_excel(buffer, index=False)
                st.success(f"‚úÖ Rela√ß√£o consolidada gerada com sucesso para {st.session_state['obra']}")
                st.download_button(
                    label="üì• Baixar planilha gerada",
                    data=buffer.getvalue(),
                    file_name=arquivo_saida,
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                )

                # Reset para um novo ciclo (n√£o ‚Äúvolta ao in√≠cio‚Äù, apenas limpa flags)
                st.session_state["pending_generate"] = False
                st.session_state["corrections_submitted"] = False
                st.session_state["correcoes_dict"] = {}
                st.session_state["correcoes_choices"] = {}
            else:
                st.warning("‚ö†Ô∏è Nenhuma estrutura v√°lida encontrada para gera√ß√£o da rela√ß√£o.")
                # Permanece em pending_generate=False para permitir nova a√ß√£o do usu√°rio
                st.session_state["pending_generate"] = False
                st.session_state["corrections_submitted"] = False
                st.session_state["correcoes_dict"] = {}
                st.session_state["correcoes_choices"] = {}

        except Exception as e:
            st.error(f"‚ùå Ocorreu um erro: {e}")
            # Reset em caso de exce√ß√£o
            st.session_state["pending_generate"] = False
            st.session_state["corrections_submitted"] = False
            st.session_state["correcoes_dict"] = {}
            st.session_state["correcoes_choices"] = {}
